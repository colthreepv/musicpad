Actual structure of backend
===========================

The entire backend is thinked to work with node.js clustering.

Consumer unit
=============

The 'Consumer' is a special piece of software that downloads and then converts the songs.
There will be N Consumer spawned per N cpu, let's assume a quad-core, so 4.

A Consumer at the startup checks if there is something to 'Consume'

Consuming is :

  * Download a queued song
  * Convert a downloaded song

If there's nothing to do, it just sits and listens for a notification to happen.

When it 'consumes' something, it will dispatch messages to the _clients_


Notifications
=============

Notifications gets generated by the `Consumer` unit when something happens:

  * Download starts
  * Download progress
  * Download ends
  * Conversion starts
  * Conversion progress
  * Conversion ends

  ... for now!

Those notifications gets broadcasted to all 'notifications channels'

### How many notifications channels?
Exactly the same numbers as clusters/cpu, so in this documentation, 4.

This number gets memorized in `internal:cluster:count`, this value _should_ always be 4.

### When a notification occours
There will be a listener in this channel (channel called: `notifications:2`, up to `4`) called `Subscriber`

This `Subscriber` handles all the notifications for a node.js process, when it receives a message,
it checks for a key in Redis:

`'client:DESTINATION:cluster'` this Redis key is a Set, and memorizes all the node.js clusters handling
a long-poll connection to the selected Token

A `client`, is someone who is listening for updates through a long-poll connection

**BEWARE**: since the nature of clustering, a client can be connected to a random node.js instance,
or to **multiple** ones! (more than 1 device, or just a dead, non-removed, connection)

Musicpad will make no assumptions about why there are multiple listeners in different clusters, it
should **just work**


Clients
=======


Queue
=====
The so-called queue is actually the download priority list.
